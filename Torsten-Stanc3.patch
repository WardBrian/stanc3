diff --git a/src/middle/Stan_math_signatures.ml b/src/middle/Stan_math_signatures.ml
index 319cfd41..133a033e 100644
--- a/src/middle/Stan_math_signatures.ml
+++ b/src/middle/Stan_math_signatures.ml
@@ -2620,6 +2620,7 @@ let () =
   add_unqualified ("zeros_array", ReturnType (UArray UReal), [UInt], SoA);
   add_unqualified ("zeros_row_vector", ReturnType URowVector, [UInt], SoA);
   add_unqualified ("zeros_vector", ReturnType UVector, [UInt], SoA);
+  Torsten.add_torsten_qualified add_qualified;
   (* Now add all the manually added stuff to the main hashtable used
      for type-checking *)
   Hashtbl.iteri manual_stan_math_signatures ~f:(fun ~key ~data ->
@@ -2683,6 +2684,16 @@ let variadic_ode_nonadjoint_fns =
     [ "ode_bdf_tol"; "ode_rk45_tol"; "ode_adams_tol"; "ode_bdf"; "ode_rk45"
     ; "ode_adams"; "ode_ckrk"; "ode_ckrk_tol" ]

+(* torsten ode *)
+let pmx_variadic_ode_fns =
+  String.Set.of_list
+    [ "pmx_ode_bdf_ctrl"; "pmx_ode_rk45_ctrl"; "pmx_ode_adams_ctrl"
+    ; "pmx_ode_bdf"; "pmx_ode_rk45"; "pmx_ode_adams"; "pmx_ode_ckrk"
+    ; "pmx_ode_ckrk_ctrl" ]
+
+let pmx_ode_control_suffix = "_ctrl"
+(* end of torsten ode *)
+
 let ode_tolerances_suffix = "_tol"
 let is_reduce_sum_fn f = Set.mem reduce_sum_functions f
 let variadic_dae_fun_return_type = UnsizedType.UVector
@@ -2715,6 +2726,16 @@ let () =
       ~required_fn_rt:variadic_ode_fun_return_type
       ~required_fn_args:variadic_ode_mandatory_fun_args () in
   Set.iter ~f:add_ode variadic_ode_nonadjoint_fns ;
+  (* Torsten ODES - same for all *)
+  let add_ode name =
+    add_variadic_fn name ~return_type:variadic_ode_return_type
+      ~control_args:
+        ( if String.is_suffix name ~suffix:pmx_ode_control_suffix then
+          variadic_ode_mandatory_arg_types @ variadic_ode_tol_arg_types
+        else variadic_ode_mandatory_arg_types )
+      ~required_fn_rt:variadic_ode_fun_return_type
+      ~required_fn_args:variadic_ode_mandatory_fun_args () in
+  Set.iter ~f:add_ode pmx_variadic_ode_fns ;
   (* Adjoint ODE function *)
   add_variadic_fn variadic_ode_adjoint_fn ~return_type:variadic_ode_return_type
     ~control_args:
diff --git a/stanc3/src/middle/Torsten.ml b/src/middle/Torsten.ml
new file mode 100644
index 00000000..108d2abc
--- /dev/null
+++ b/src/middle/Torsten.ml
@@ -0,0 +1,337 @@
+open Core
+
+(* old ODE RHS def *)
+let pmx_ode_func =
+  [ ( UnsizedType.AutoDiffable
+    , UnsizedType.UFun
+        ( [ (UnsizedType.AutoDiffable, UnsizedType.UReal)
+          ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal)
+          ; (UnsizedType.AutoDiffable, UArray UReal); (DataOnly, UArray UReal)
+          ; (DataOnly, UArray UInt) ]
+        , ReturnType (UnsizedType.UArray UReal)
+        , FnPlain
+        , Mem_pattern.AoS ) ) ]
+
+(* new ODE RHS def *)
+let pmx_solve_ode_func =
+  [ ( UnsizedType.AutoDiffable
+    , UnsizedType.UFun
+        ( [ (UnsizedType.AutoDiffable, UnsizedType.UReal)
+          ; (UnsizedType.AutoDiffable, UnsizedType.UVector)
+          ; (UnsizedType.AutoDiffable, UArray UReal); (DataOnly, UArray UReal)
+          ; (DataOnly, UArray UInt) ]
+        , ReturnType UnsizedType.UVector
+        , FnPlain
+        , Mem_pattern.AoS ) ) ]
+
+let pmx_coupled_ode_func =
+  [ ( UnsizedType.AutoDiffable
+    , UnsizedType.UFun
+        ( [ (UnsizedType.AutoDiffable, UnsizedType.UReal)
+          ; (UnsizedType.AutoDiffable, UnsizedType.UVector)
+          ; (UnsizedType.AutoDiffable, UnsizedType.UVector)
+          ; (UnsizedType.AutoDiffable, UArray UReal); (DataOnly, UArray UReal)
+          ; (DataOnly, UArray UInt) ]
+        , ReturnType UnsizedType.UVector
+        , FnPlain
+        , Mem_pattern.AoS ) ) ]
+
+let pmx_integrate_ode_arg =
+  [ (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* y0 *)
+  ; (UnsizedType.AutoDiffable, UReal) (* t0 *)
+  ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* ts *)
+  ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* theta *)
+  ; (DataOnly, UnsizedType.UArray UReal) (* x_r *)
+  ; (DataOnly, UnsizedType.UArray UInt) ]
+(* x_i *)
+
+let pmx_integrate_ode_tol =
+  [ (UnsizedType.DataOnly, UnsizedType.UReal) (* rtol *)
+  ; (UnsizedType.DataOnly, UnsizedType.UReal) (* atol *)
+  ; (UnsizedType.DataOnly, UnsizedType.UReal) ]
+(* mxstep *)
+
+let pmx_algebra_sol_tol = pmx_integrate_ode_tol
+
+let pmx_integrate_ode_group_arg =
+  [ (UnsizedType.AutoDiffable, UnsizedType.UArray (UnsizedType.UArray UReal))
+    (* y0 *); (UnsizedType.AutoDiffable, UReal) (* t0 *)
+  ; (DataOnly, UnsizedType.UArray UInt) (* len *)
+  ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* ts *)
+  ; (UnsizedType.AutoDiffable, UnsizedType.UArray (UnsizedType.UArray UReal))
+    (* theta *)
+  ; (DataOnly, UnsizedType.UArray (UnsizedType.UArray UReal)) (* x_r *)
+  ; (DataOnly, UnsizedType.UArray (UnsizedType.UArray UInt)) ]
+(* x_i *)
+
+let rec pmx_ode_group add_func name args_list =
+  match args_list with
+  | [] -> ()
+  | head :: tail ->
+      add_func
+        ( name
+        , UnsizedType.ReturnType UMatrix
+        , pmx_ode_func @ head
+        , Mem_pattern.AoS ) ;
+      pmx_ode_group add_func name tail
+
+(* from rosettacode.org *)
+let rec cart_prod_list l =
+  (* We need to do the cross product of our current list and all the others
+   * so we define a helper function for that *)
+  let rec aux ~acc l1 l2 =
+    match (l1, l2) with
+    | [], _ | _, [] -> acc
+    | h1 :: t1, h2 :: t2 ->
+        let acc = (h1 :: h2) :: acc in
+        let acc = aux ~acc t1 l2 in
+        aux ~acc [h1] t2
+    (* now we can do the actual computation *) in
+  match l with
+  | [] -> []
+  | [l1] -> List.map ~f:(fun x -> [x]) l1
+  | l1 :: tl ->
+      let tail_product = cart_prod_list tl in
+      aux ~acc:[] l1 tail_product
+
+let rec pmx_solve_cpt add_func name args_list =
+  let pmx_event_args =
+    [ (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* time *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* amt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* rate *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* ii *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* evid *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* cmt *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* addl *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) ] in
+  (* ss *)
+  match args_list with
+  | [] -> ()
+  | head :: tail ->
+      add_func
+        ( name
+        , UnsizedType.ReturnType UMatrix
+        , pmx_event_args @ head
+        , Mem_pattern.AoS ) ;
+      pmx_solve_cpt add_func name tail
+
+let rec pmx_solve add_func name args_list =
+  let pmx_event_args =
+    [ (UnsizedType.DataOnly, UnsizedType.UInt) (* nCmt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* time *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* amt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* rate *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* ii *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* evid *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* cmt *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* addl *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) ] in
+  (* ss *)
+  match args_list with
+  | [] -> ()
+  | head :: tail ->
+      add_func
+        ( name
+        , UnsizedType.ReturnType UMatrix
+        , pmx_solve_ode_func @ pmx_event_args @ head
+        , Mem_pattern.AoS ) ;
+      pmx_solve add_func name tail
+
+let rec pmx_solve_coupled add_func name args_list =
+  let pmx_event_args =
+    [ (UnsizedType.DataOnly, UnsizedType.UInt) (* nCmt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* time *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* amt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* rate *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* ii *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* evid *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* cmt *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* addl *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) ] in
+  (* ss *)
+  match args_list with
+  | [] -> ()
+  | head :: tail ->
+      add_func
+        ( name
+        , UnsizedType.ReturnType UMatrix
+        , pmx_coupled_ode_func @ pmx_event_args @ head
+        , Mem_pattern.AoS ) ;
+      pmx_solve_coupled add_func name tail
+
+let rec pmx_solve_group add_func name args_list =
+  let pmx_event_args =
+    [ (UnsizedType.DataOnly, UnsizedType.UInt) (* nCmt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UInt) (* length *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* time *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* amt *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* rate *)
+    ; (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) (* ii *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* evid *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* cmt *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) (* addl *)
+    ; (UnsizedType.DataOnly, UnsizedType.UArray UInt) ] in
+  (* ss *)
+  match args_list with
+  | [] -> ()
+  | head :: tail ->
+      add_func
+        ( name
+        , UnsizedType.ReturnType UMatrix
+        , pmx_solve_ode_func @ pmx_event_args @ head
+        , Mem_pattern.AoS ) ;
+      pmx_solve_group add_func name tail
+
+let pmx_solve_args, pmx_group_args, pmx_solve_cpt_args =
+  let pmx_param_1d, pmx_param_2d =
+    ( [(UnsizedType.AutoDiffable, UnsizedType.UArray UReal)]
+    , [(UnsizedType.AutoDiffable, UnsizedType.UArray (UArray UReal))] ) in
+  let pmx_r_data, pmx_i_data =
+    ( [(UnsizedType.DataOnly, UnsizedType.UArray (UArray UReal))]
+    , [(UnsizedType.DataOnly, UnsizedType.UArray (UArray UInt))] ) in
+  let pmx_param = pmx_param_1d @ pmx_param_2d in
+  let pmx_solve_args_0 =
+    cart_prod_list [pmx_param; pmx_param; pmx_param; pmx_r_data; pmx_i_data]
+    @ cart_prod_list [pmx_param; pmx_param; pmx_param; pmx_r_data]
+    @ cart_prod_list [pmx_param; pmx_param; pmx_param]
+    @ cart_prod_list [pmx_param; pmx_param]
+    @ cart_prod_list [pmx_param] in
+  let pmx_group_args_0 =
+    cart_prod_list
+      [pmx_param_2d; pmx_param_2d; pmx_param_2d; pmx_r_data; pmx_i_data]
+    @ cart_prod_list [pmx_param_2d; pmx_param_2d; pmx_param_2d; pmx_r_data]
+    @ cart_prod_list [pmx_param_2d; pmx_param_2d; pmx_param_2d]
+    @ cart_prod_list [pmx_param_2d; pmx_param_2d]
+    @ cart_prod_list [pmx_param_2d] in
+  let pmx_solve_args_w_ode_tol =
+    List.map ~f:(fun l -> l @ pmx_integrate_ode_tol) pmx_solve_args_0 in
+  let pmx_solve_args_w_all_tol =
+    List.map
+      ~f:(fun l -> l @ pmx_integrate_ode_tol @ pmx_algebra_sol_tol)
+      pmx_solve_args_0 in
+  let pmx_group_args_w_ode_tol =
+    List.map ~f:(fun l -> l @ pmx_integrate_ode_tol) pmx_group_args_0 in
+  let pmx_group_args_w_all_tol =
+    List.map
+      ~f:(fun l -> l @ pmx_integrate_ode_tol @ pmx_algebra_sol_tol)
+      pmx_group_args_0 in
+  ( pmx_solve_args_0 @ pmx_solve_args_w_ode_tol @ pmx_solve_args_w_all_tol
+  , pmx_group_args_0 @ pmx_group_args_w_ode_tol @ pmx_group_args_w_all_tol
+  , cart_prod_list [pmx_param; pmx_param; pmx_param]
+    @ cart_prod_list [pmx_param; pmx_param]
+    @ cart_prod_list [pmx_param] )
+
+let pmx_solve_coupled_args =
+  let pmx_param_1d = (UnsizedType.AutoDiffable, UnsizedType.UArray UReal) in
+  let pmx_param_2d =
+    (UnsizedType.AutoDiffable, UnsizedType.UArray (UArray UReal)) in
+  let pmx_solve_args_0 =
+    [ [pmx_param_1d; pmx_param_1d; pmx_param_1d]
+    ; [pmx_param_2d; pmx_param_2d; pmx_param_2d] ] in
+  let pmx_solve_args_w_ode_tol =
+    List.map ~f:(fun l -> l @ pmx_integrate_ode_tol) pmx_solve_args_0 in
+  let pmx_solve_args_w_all_tol =
+    List.map
+      ~f:(fun l -> l @ pmx_integrate_ode_tol @ pmx_algebra_sol_tol)
+      pmx_solve_args_0 in
+  pmx_solve_args_0 @ pmx_solve_args_w_ode_tol @ pmx_solve_args_w_all_tol
+
+(* torsten functions *)
+let add_torsten_qualified add_func =
+  let sol_names =
+    List.map
+      ~f:(fun sol -> "pmx_integrate_ode_group_" ^ sol)
+      ["adams"; "bdf"; "rk45"] in
+  List.iter
+    ~f:(fun sol ->
+      pmx_ode_group add_func sol
+        [ pmx_integrate_ode_group_arg @ pmx_integrate_ode_tol
+        ; pmx_integrate_ode_group_arg ] )
+    sol_names ;
+  let sol_names =
+    List.map ~f:(fun sol -> "pmx_solve_" ^ sol) ["adams"; "bdf"; "rk45"] in
+  List.iter ~f:(fun sol -> pmx_solve add_func sol pmx_solve_args) sol_names ;
+  let sol_names =
+    List.map ~f:(fun sol -> "pmx_solve_group_" ^ sol) ["adams"; "bdf"; "rk45"]
+  in
+  List.iter
+    ~f:(fun sol -> pmx_solve_group add_func sol pmx_group_args)
+    sol_names ;
+  let sol_names =
+    List.map
+      ~f:(fun sol -> "pmx_solve_" ^ sol)
+      ["onecpt"; "twocpt"; "onecpt_effcpt"; "twocpt_effcpt"] in
+  List.iter
+    ~f:(fun sol -> pmx_solve_cpt add_func sol pmx_solve_cpt_args)
+    sol_names ;
+  let sol_names =
+    List.map ~f:(fun sol -> "pmx_solve_onecpt_" ^ sol) ["bdf"; "rk45"] in
+  List.iter
+    ~f:(fun sol -> pmx_solve_coupled add_func sol pmx_solve_coupled_args)
+    sol_names ;
+  let sol_names =
+    List.map ~f:(fun sol -> "pmx_solve_twocpt_" ^ sol) ["bdf"; "rk45"] in
+  List.iter
+    ~f:(fun sol -> pmx_solve_coupled add_func sol pmx_solve_coupled_args)
+    sol_names ;
+  (* pmx_solve_linode *)
+  add_func
+    ( "pmx_solve_linode"
+    , ReturnType UMatrix
+    , [ (AutoDiffable, UArray UReal) (* time *)
+      ; (AutoDiffable, UArray UReal) (* amt *)
+      ; (AutoDiffable, UArray UReal) (* rate *)
+      ; (AutoDiffable, UArray UReal) (* ii *)
+      ; (DataOnly, UArray UInt) (* evid *); (DataOnly, UArray UInt) (* cmt *)
+      ; (DataOnly, UArray UInt) (* addl *); (DataOnly, UArray UInt) (* ss *)
+      ; (AutoDiffable, UArray UMatrix) (* pMatrix *)
+      ; (AutoDiffable, UArray (UArray UReal)) (* biovar *)
+      ; (AutoDiffable, UArray (UArray UReal)) ]
+    , Mem_pattern.AoS ) ;
+  (* tlag *)
+  add_func
+    ( "pmx_solve_linode"
+    , ReturnType UMatrix
+    , [ (AutoDiffable, UArray UReal) (* time *)
+      ; (AutoDiffable, UArray UReal) (* amt *)
+      ; (AutoDiffable, UArray UReal) (* rate *)
+      ; (AutoDiffable, UArray UReal) (* ii *)
+      ; (DataOnly, UArray UInt) (* evid *); (DataOnly, UArray UInt) (* cmt *)
+      ; (DataOnly, UArray UInt) (* addl *); (DataOnly, UArray UInt) (* ss *)
+      ; (AutoDiffable, UMatrix) (* pMatrix *)
+      ; (AutoDiffable, UArray UReal) (* biovar *); (AutoDiffable, UArray UReal)
+      ]
+    , Mem_pattern.AoS ) ;
+  (* tlag *)
+  add_func
+    ( "pmx_solve_linode"
+    , ReturnType UMatrix
+    , [ (AutoDiffable, UArray UReal) (* time *)
+      ; (AutoDiffable, UArray UReal) (* amt *)
+      ; (AutoDiffable, UArray UReal) (* rate *)
+      ; (AutoDiffable, UArray UReal) (* ii *)
+      ; (DataOnly, UArray UInt) (* evid *); (DataOnly, UArray UInt) (* cmt *)
+      ; (DataOnly, UArray UInt) (* addl *); (DataOnly, UArray UInt) (* ss *)
+      ; (AutoDiffable, UArray UMatrix) (* pMatrix *)
+      ; (AutoDiffable, UArray UReal) (* biovar *); (AutoDiffable, UArray UReal)
+      ]
+    , Mem_pattern.AoS ) ;
+  (* tlag *)
+
+  (* linear interpolation *)
+  add_func
+    ( "pmx_linear_interpolation"
+    , ReturnType UReal
+    , [ (AutoDiffable, UReal) (* x_out *); (AutoDiffable, UArray UReal) (* x *)
+      ; (AutoDiffable, UArray UReal) ]
+    , Mem_pattern.AoS ) ;
+  (* y *)
+  add_func
+    ( "pmx_linear_interpolation"
+    , ReturnType (UArray UReal)
+    , [ (AutoDiffable, UArray UReal) (* x_out *)
+      ; (AutoDiffable, UArray UReal) (* x *); (AutoDiffable, UArray UReal) ]
+    , Mem_pattern.AoS )
+(* y *)
+
+(* end of torsten signatures *)
diff --git a/src/stan_math_backend/Lower_expr.ml b/src/stan_math_backend/Lower_expr.ml
index 3067cb3e..edc5d6f0 100644
--- a/src/stan_math_backend/Lower_expr.ml
+++ b/src/stan_math_backend/Lower_expr.ml
@@ -7,6 +7,7 @@ open Cpp

 let stan_namespace_qualify f =
   if String.is_suffix ~suffix:"functor__" f || String.contains f ':' then f
+  else if String.is_prefix ~prefix:"pmx_solve_" f || String.is_prefix ~prefix:"pmx_ode_" f then "torsten::" ^ f
   else "stan::math::" ^ f

 let fn_renames =
