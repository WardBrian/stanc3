  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined bernoulli.stan
#include /pre/Columbia_copyright.stan
#include /pre/license.stan

functions {
  #include /functions/common_functions.stan
  #include /functions/bernoulli_likelihoods.stan
}
data {
  int<lower=0> K;
  array[2] int<lower=1> N;
  vector[K] xbar;
  int<lower=0, upper=1> dense_X;
  array[dense_X] matrix[N[1], K] X0;
  array[dense_X] matrix[N[2], K] X1;
  
  int<lower=0, upper=1> clogit;
  int<lower=0> J;
  array[clogit == 1 ? N[1] + N[2] : 0] int<lower=1, upper=J> strata;
  
  int<lower=0> nnz_X0;
  vector[nnz_X0] w_X0;
  array[nnz_X0] int<lower=0, upper=K - 1> v_X0;
  
  array[dense_X ? 0 : N[1] + 1] int<lower=0, upper=rows(w_X0) + 1> u_X0;
  int<lower=0> nnz_X1;
  vector[nnz_X1] w_X1;
  array[nnz_X1] int<lower=0, upper=K - 1> v_X1;
  
  array[dense_X ? 0 : N[2] + 1] int<lower=0, upper=rows(w_X1) + 1> u_X1;
  
  #include /data/data_glm.stan
  
  int<lower=0> K_smooth;
  matrix[N[1], K_smooth] S0;
  matrix[N[2], K_smooth] S1;
  array[K_smooth] int<lower=1> smooth_map;
  
  int<lower=5, upper=5> family;
  
  int<lower=0, upper=1> has_weights;
  vector[has_weights ? N[1] : 0] weights0;
  vector[has_weights ? N[2] : 0] weights1;
  
  int<lower=0, upper=1> has_offset;
  vector[has_offset ? N[1] : 0] offset0;
  vector[has_offset ? N[2] : 0] offset1;
  
  #include /data/hyperparameters.stan
  
  #include /data/glmer_stuff.stan
  
  array[2] int<lower=0> num_non_zero;
  vector[num_non_zero[1]] w0;
  vector[num_non_zero[2]] w1;
  array[num_non_zero[1]] int<lower=0, upper=q - 1> v0;
  array[num_non_zero[2]] int<lower=0, upper=q - 1> v1;
  
  array[t > 0 ? N[1] + 1 : 0] int<lower=0, upper=rows(w0) + 1> u0;
  
  array[t > 0 ? N[2] + 1 : 0] int<lower=0, upper=rows(w1) + 1> u1;
  int<lower=0, upper=1> special_case;
}
transformed data {
  int NN = N[1] + N[2];
  real aux = not_a_number();
  array[special_case ? t : 0, N[1]] int<lower=1> V0 = make_V(N[1],
                                                             special_case ? t
                                                             : 0, v0);
  array[special_case ? t : 0, N[2]] int<lower=1> V1 = make_V(N[2],
                                                             special_case ? t
                                                             : 0, v1);
  array[clogit ? J : 0] int<lower=0> successes;
  array[clogit ? J : 0] int<lower=0> failures;
  array[clogit ? J : 0] int<lower=0> observations;
  
  #include /tdata/tdata_glm.stan
  
  for (j in 1 : J) {
    successes[j] = 0;
    failures[j] = 0;
  }
  if (J > 0) 
    for (i in 1 : N[2]) 
      successes[strata[i]] += 1;
  if (J > 0) 
    for (i in (N[2] + 1) : NN) 
      failures[strata[i]] += 1;
  for (j in 1 : J) 
    observations[j] = failures[j] + successes[j];
}
parameters {
  array[has_intercept] real<upper=(link == 4 ? 0.0 : positive_infinity())> gamma;
  
  #include /parameters/parameters_glm.stan
}
transformed parameters {
  #include /tparameters/tparameters_glm.stan
  
  if (t > 0) {
    if (special_case) {
      int start = 1;
      theta_L = scale .* tau;
      if (t == 1) 
        b = theta_L[1] * z_b;
      else 
        for (i in 1 : t) {
          int end = start + l[i] - 1;
          b[start : end] = theta_L[i] * z_b[start : end];
          start = end + 1;
        }
    } else {
      theta_L = make_theta_L(len_theta_L, p, 1.0, tau, scale, zeta, rho, z_T);
      b = make_b(z_b, theta_L, p, l);
    }
  }
}
model {
  #include /model/make_eta_bern.stan
  
  if (has_intercept == 1) {
    if (link != 4) {
      eta0 += gamma[1];
      eta1 += gamma[1];
    } else {
      real shift = fmax(max(eta0), max(eta1));
      eta0 += gamma[1] - shift;
      eta1 += gamma[1] - shift;
    }
  }
  
  if (clogit && prior_PD == 0) {
    real dummy = ll_clogit_lp(eta0, eta1, successes, failures, observations);
  } else if (has_weights == 0 && prior_PD == 0) {
    real dummy = ll_bern_lp(eta0, eta1, link, N);
  } else if (prior_PD == 0) {
    target += dot_product(weights0, pw_bern(0, eta0, link));
    target += dot_product(weights1, pw_bern(1, eta1, link));
  }
  
  #include /model/priors_glm.stan
  
  if (t > 0) {
    real dummy = decov_lp(z_b, z_T, rho, zeta, tau, regularization, delta,
                          shape, t, p);
  }
}
generated quantities {
  real mean_PPD = compute_mean_PPD ? 0 : negative_infinity();
  array[has_intercept] real alpha;
  
  if (has_intercept == 1) {
    if (dense_X) 
      alpha[1] = gamma[1] - dot_product(xbar, beta);
    else 
      alpha[1] = gamma[1];
  }
  
  if (compute_mean_PPD) {
    vector[N[1]] pi0;
    vector[N[2]] pi1;
    
    #include /model/make_eta_bern.stan
    
    if (has_intercept == 1) {
      if (link != 4) {
        eta0 += gamma[1];
        eta1 += gamma[1];
      } else {
        real shift;
        shift = fmax(max(eta0), max(eta1));
        eta0 += gamma[1] - shift;
        eta1 += gamma[1] - shift;
        alpha[1] -= shift;
      }
    }
    if (clogit) 
      for (j in 1 : J) 
        mean_PPD += successes[j];
    else {
      pi0 = linkinv_bern(eta0, link);
      pi1 = linkinv_bern(eta1, link);
      for (n in 1 : N[1]) 
        mean_PPD += bernoulli_rng(pi0[n]);
      for (n in 1 : N[2]) 
        mean_PPD += bernoulli_rng(pi1[n]);
    }
    mean_PPD /= NN;
  }
}

Warning in './/functions/bernoulli_likelihoods.stan', line 84, column 7, included from
'bernoulli.stan', line 7, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined binomial.stan
#include /pre/Columbia_copyright.stan
#include /pre/license.stan

functions {
  #include /functions/common_functions.stan
  #include /functions/binomial_likelihoods.stan
}
data {
  #include /data/NKX.stan
  
  array[N] int<lower=0> y;
  array[N] int<lower=0> trials;
  
  #include /data/data_glm.stan
  
  #include /data/weights_offset.stan
  
  int<lower=5, upper=5> family;
  
  #include /data/hyperparameters.stan
  
  #include /data/glmer_stuff.stan
  
  #include /data/glmer_stuff2.stan
}
transformed data {
  real aux = not_a_number();
  array[special_case ? t : 0, N] int<lower=1> V = make_V(N,
                                                         special_case ? t : 0,
                                                         v);
  
  #include /tdata/tdata_glm.stan
}
parameters {
  array[has_intercept] real<upper=(link == 4 ? 0.0 : positive_infinity())> gamma;
  
  #include /parameters/parameters_glm.stan
}
transformed parameters {
  #include /tparameters/tparameters_glm.stan
  
  if (t > 0) {
    if (special_case == 1) {
      int start = 1;
      theta_L = scale .* tau;
      if (t == 1) 
        b = theta_L[1] * z_b;
      else 
        for (i in 1 : t) {
          int end = start + l[i] - 1;
          b[start : end] = theta_L[i] * z_b[start : end];
          start = end + 1;
        }
    } else {
      theta_L = make_theta_L(len_theta_L, p, 1.0, tau, scale, zeta, rho, z_T);
      b = make_b(z_b, theta_L, p, l);
    }
  }
}
model {
  #include /model/make_eta.stan
  
  if (t > 0) {
    #include /model/eta_add_Zb.stan
  }
  if (has_intercept == 1) {
    if (link != 4) 
      eta += gamma[1];
    else 
      eta += gamma[1] - max(eta);
  } else {
    #include /model/eta_no_intercept.stan
  }
  
  if (has_weights == 0 && prior_PD == 0) {
    real dummy = ll_binom_lp(y, trials, eta, link);
  } else if (prior_PD == 0) 
    target += dot_product(weights, pw_binom(y, trials, eta, link));
  
  #include /model/priors_glm.stan
  
  if (t > 0) {
    real dummy = decov_lp(z_b, z_T, rho, zeta, tau, regularization, delta,
                          shape, t, p);
  }
}
generated quantities {
  real mean_PPD = compute_mean_PPD ? 0 : negative_infinity();
  array[has_intercept] real alpha;
  
  if (has_intercept == 1) {
    if (dense_X) 
      alpha[1] = gamma[1] - dot_product(xbar, beta);
    else 
      alpha[1] = gamma[1];
  }
  
  if (compute_mean_PPD) {
    vector[N] pi;
    #include /model/make_eta.stan
    
    if (t > 0) {
      #include /model/eta_add_Zb.stan
    }
    if (has_intercept == 1) {
      if (link != 4) 
        eta += gamma[1];
      else {
        real shift = max(eta);
        eta += gamma[1] - shift;
        alpha[1] -= shift;
      }
    } else {
      #include /model/eta_no_intercept.stan
    }
    
    pi = linkinv_binom(eta, link);
    for (n in 1 : N) 
      mean_PPD += binomial_rng(trials[n], pi[n]);
    mean_PPD /= N;
  }
}

  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined continuous.stan
#include /pre/Columbia_copyright.stan
#include /pre/license.stan

functions {
  #include /functions/common_functions.stan
  #include /functions/continuous_likelihoods.stan
  
  #include /functions/SSfunctions.stan
  
  vector test_csr_matrix_times_vector(int m, int n, vector w, array[] int v,
                                      array[] int u, vector b) {
    return csr_matrix_times_vector(m, n, w, v, u, b);
  }
}
data {
  #include /data/NKX.stan
  
  int<lower=0> len_y;
  real lb_y;
  real<lower=lb_y> ub_y;
  vector<lower=lb_y, upper=ub_y>[len_y] y;
  int<lower=1, upper=4> family;
  
  #include /data/data_glm.stan
  
  #include /data/weights_offset.stan
  
  #include /data/hyperparameters.stan
  
  #include /data/glmer_stuff.stan
  
  #include /data/glmer_stuff2.stan
  #include /data/data_betareg.stan
  
  int<lower=0, upper=10> SSfun;
  vector[SSfun > 0 ? len_y : 0] input;
  vector[SSfun == 5 ? len_y : 0] Dose;
}
transformed data {
  vector[family == 3 ? len_y : 0] sqrt_y;
  vector[family == 3 ? len_y : 0] log_y;
  real sum_log_y = family == 1 ? not_a_number() : sum(log(y));
  array[special_case ? t : 0, len_y] int<lower=1> V = make_V(len_y,
                                                             special_case ? t
                                                             : 0, v);
  int<lower=0> hs_z;
  
  #include /tdata/tdata_glm.stan
  
  #include /tdata/tdata_betareg.stan
  
  is_continuous = 1;
  
  if (family == 3) {
    sqrt_y = sqrt(y);
    log_y = log(y);
  }
}
parameters {
  array[has_intercept] real<lower=make_lower(family, link),
                            upper=make_upper(family, link)> gamma;
  
  #include /parameters/parameters_glm.stan
  
  real<lower=0> aux_unscaled;
  #include /parameters/parameters_betareg.stan
}
transformed parameters {
  real aux = prior_dist_for_aux == 0 ? aux_unscaled
             : (prior_dist_for_aux <= 2
                ? prior_scale_for_aux * aux_unscaled + prior_mean_for_aux
                : prior_scale_for_aux * aux_unscaled);
  
  vector[z_dim] omega;
  
  #include /tparameters/tparameters_glm.stan
  #include /tparameters/tparameters_betareg.stan
  
  if (prior_dist_for_aux == 0) 
    aux = aux_unscaled;
  else {
    aux = prior_scale_for_aux * aux_unscaled;
    if (prior_dist_for_aux <= 2) 
      aux += prior_mean_for_aux;
  }
  
  if (t > 0) {
    if (special_case == 1) {
      int start = 1;
      theta_L = scale .* tau * aux;
      if (t == 1) 
        b = theta_L[1] * z_b;
      else 
        for (i in 1 : t) {
          int end = start + l[i] - 1;
          b[start : end] = theta_L[i] * z_b[start : end];
          start = end + 1;
        }
    } else {
      theta_L = make_theta_L(len_theta_L, p, aux, tau, scale, zeta, rho, z_T);
      b = make_b(z_b, theta_L, p, l);
    }
  }
}
model {
  vector[N] eta_z;
  #include /model/make_eta.stan
  
  if (t > 0) {
    #include /model/eta_add_Zb.stan
  }
  if (has_intercept == 1) {
    if ((family == 1 || link == 2) || (family == 4 && link != 5)) 
      eta += gamma[1];
    else if (family == 4 && link == 5) 
      eta += gamma[1] - max(eta);
    else 
      eta += gamma[1] - min(eta);
  } else {
    #include /model/eta_no_intercept.stan
  }
  
  if (SSfun > 0) {
    matrix[len_y, K] P = reshape_vec(eta, len_y, K);
    if (SSfun < 5) {
      if (SSfun <= 2) {
        if (SSfun == 1) 
          target += normal_lpdf(y | SS_asymp(input, P), aux);
        else 
          target += normal_lpdf(y | SS_asympOff(input, P), aux);
      } else if (SSfun == 3) 
        target += normal_lpdf(y | SS_asympOrig(input, P), aux);
      else {
        for (i in 1 : len_y) 
          P[i, 1] += exp(P[i, 3]);
        target += normal_lpdf(y | SS_biexp(input, P), aux);
      }
    } else {
      if (SSfun <= 7) {
        if (SSfun == 5) 
          target += normal_lpdf(y | SS_fol(Dose, input, P), aux);
        else if (SSfun == 6) 
          target += normal_lpdf(y | SS_fpl(input, P), aux);
        else 
          target += normal_lpdf(y | SS_gompertz(input, P), aux);
      } else {
        if (SSfun == 8) 
          target += normal_lpdf(y | SS_logis(input, P), aux);
        else if (SSfun == 9) 
          target += normal_lpdf(y | SS_micmen(input, P), aux);
        else 
          target += normal_lpdf(y | SS_weibull(input, P), aux);
      }
    }
  } else if (has_weights == 0 && prior_PD == 0) {
    #include /model/make_eta_z.stan
    
    if (has_intercept_z == 1) {
      if (link_phi > 1) {
        eta_z += gamma_z[1] - min(eta_z);
      } else {
        eta_z += gamma_z[1];
      }
    } else {
      #include /model/eta_z_no_intercept.stan
    }
    if (family == 1) {
      if (link == 1) 
        target += normal_lpdf(y | eta, aux);
      else if (link == 2) 
        target += normal_lpdf(y | exp(eta), aux);
      else 
        target += normal_lpdf(y | inv(eta), aux);
    } else if (family == 2) {
      target += GammaReg(y, eta, aux, link, sum_log_y);
    } else if (family == 3) {
      target += inv_gaussian(y, linkinv_inv_gaussian(eta, link), aux,
                             sum_log_y, sqrt_y);
    } else if (family == 4 && link_phi == 0) {
      vector[N] mu;
      mu = linkinv_beta(eta, link);
      target += beta_lpdf(y | mu * aux, (1 - mu) * aux);
    } else if (family == 4 && link_phi > 0) {
      vector[N] mu;
      vector[N] mu_z;
      mu = linkinv_beta(eta, link);
      mu_z = linkinv_beta_z(eta_z, link_phi);
      target += beta_lpdf(y | rows_dot_product(mu, mu_z), rows_dot_product((
                                                                    1 - mu),
                                                                    mu_z));
    }
  } else if (prior_PD == 0) {
    vector[N] summands;
    if (family == 1) 
      summands = pw_gauss(y, eta, aux, link);
    else if (family == 2) 
      summands = pw_gamma(y, eta, aux, link);
    else if (family == 3) 
      summands = pw_inv_gaussian(y, eta, aux, link, log_y, sqrt_y);
    else if (family == 4 && link_phi == 0) 
      summands = pw_beta(y, eta, aux, link);
    else if (family == 4 && link_phi > 0) 
      summands = pw_beta_z(y, eta, eta_z, link, link_phi);
    target += dot_product(weights, summands);
  }
  
  if (prior_dist_for_aux > 0 && prior_scale_for_aux > 0) {
    real log_half = -0.693147180559945286;
    if (prior_dist_for_aux == 1) 
      target += normal_lpdf(aux_unscaled | 0, 1) - log_half;
    else if (prior_dist_for_aux == 2) 
      target += student_t_lpdf(aux_unscaled | prior_df_for_aux, 0, 1)
                - log_half;
    else 
      target += exponential_lpdf(aux_unscaled | 1);
  }
  
  #include /model/priors_glm.stan
  #include /model/priors_betareg.stan
  
  if (t > 0) {
    real dummy = decov_lp(z_b, z_T, rho, zeta, tau, regularization, delta,
                          shape, t, p);
  }
}
generated quantities {
  real mean_PPD = compute_mean_PPD ? 0 : negative_infinity();
  array[has_intercept] real alpha;
  array[has_intercept_z] real omega_int;
  
  if (has_intercept == 1) {
    if (dense_X) 
      alpha[1] = gamma[1] - dot_product(xbar, beta);
    else 
      alpha[1] = gamma[1];
  }
  if (has_intercept_z == 1) {
    omega_int[1] = gamma_z[1] - dot_product(zbar, omega);
  }
  
  if (compute_mean_PPD) {
    vector[N] eta_z;
    #include /model/make_eta.stan
    
    if (t > 0) {
      #include /model/eta_add_Zb.stan
    }
    if (has_intercept == 1) {
      if (make_lower(family, link) == negative_infinity()
          && make_upper(family, link) == positive_infinity()) 
        eta += gamma[1];
      else if (family == 4 && link == 5) {
        real max_eta = max(eta);
        alpha[1] -= max_eta;
        eta += gamma[1] - max_eta;
      } else {
        real min_eta = min(eta);
        alpha[1] -= min_eta;
        eta += gamma[1] - min_eta;
      }
    } else {
      #include /model/eta_no_intercept.stan
    }
    #include /model/make_eta_z.stan
    
    if (has_intercept_z == 1) {
      if (link_phi > 1) {
        omega_int[1] -= min(eta_z);
        eta_z += gamma_z[1] - min(eta_z);
      } else {
        eta_z += gamma_z[1];
      }
    } else {
      #include /model/eta_z_no_intercept.stan
    }
    
    if (SSfun > 0) {
      vector[len_y] eta_nlmer;
      matrix[len_y, K] P;
      P = reshape_vec(eta, len_y, K);
      if (SSfun < 5) {
        if (SSfun <= 2) {
          if (SSfun == 1) 
            eta_nlmer = SS_asymp(input, P);
          else 
            eta_nlmer = SS_asympOff(input, P);
        } else if (SSfun == 3) 
          eta_nlmer = SS_asympOrig(input, P);
        else 
          eta_nlmer = SS_biexp(input, P);
      } else {
        if (SSfun <= 7) {
          if (SSfun == 5) 
            eta_nlmer = SS_fol(Dose, input, P);
          else if (SSfun == 6) 
            eta_nlmer = SS_fpl(input, P);
          else 
            eta_nlmer = SS_gompertz(input, P);
        } else {
          if (SSfun == 8) 
            eta_nlmer = SS_logis(input, P);
          else if (SSfun == 9) 
            eta_nlmer = SS_micmen(input, P);
          else 
            eta_nlmer = SS_weibull(input, P);
        }
      }
      for (n in 1 : len_y) 
        mean_PPD += normal_rng(eta_nlmer[n], aux);
    } else if (family == 1) {
      vector[N] mu = link > 1 ? linkinv_gauss(eta, link) : eta;
      for (n in 1 : len_y) 
        mean_PPD += normal_rng(mu[n], aux);
    } else if (family == 2) {
      vector[N] mu = link > 1 ? linkinv_gamma(eta, link) : eta;
      for (n in 1 : len_y) 
        mean_PPD += gamma_rng(aux, aux / mu[n]);
    } else if (family == 3) {
      vector[N] mu = link > 1 ? linkinv_inv_gaussian(eta, link) : eta;
      for (n in 1 : len_y) 
        mean_PPD += inv_gaussian_rng(mu[n], aux);
    } else if (family == 4 && link_phi == 0) {
      vector[N] mu = linkinv_beta(eta, link);
      for (n in 1 : N) {
        real mu_n = mu[n];
        if (aux <= 0) 
          mean_PPD += bernoulli_rng(0.5);
        else if (mu_n >= 1) 
          mean_PPD += 1;
        else if (mu_n > 0) 
          mean_PPD += beta_rng(mu_n * aux, (1 - mu_n) * aux);
      }
    } else if (family == 4 && link_phi > 0) {
      vector[N] mu = linkinv_beta(eta, link);
      vector[N] phi = linkinv_beta_z(eta_z, link_phi);
      for (n in 1 : N) {
        real mu_n = mu[n];
        real aux_n = phi[n];
        if (aux_n <= 0) 
          mean_PPD += bernoulli_rng(0.5);
        else if (mu_n >= 1) 
          mean_PPD += 1;
        else if (mu_n > 0) 
          mean_PPD += beta_rng(mu_n * aux_n, (1 - mu_n) * aux_n);
      }
    }
    mean_PPD /= len_y;
  }
}

Warning in './/functions/SSfunctions.stan', line 1, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 2, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 3, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 4, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 5, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 6, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 7, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 8, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 9, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
Warning in './/functions/SSfunctions.stan', line 10, column 7, included from
'continuous.stan', line 9, column 2: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined count.stan
#include /pre/Columbia_copyright.stan
#include /pre/license.stan

functions {
  #include /functions/common_functions.stan
  #include /functions/count_likelihoods.stan
}
data {
  #include /data/NKX.stan
  
  array[N] int<lower=0> y;
  
  #include /data/data_glm.stan
  
  #include /data/weights_offset.stan
  
  int<lower=6, upper=7> family;
  
  #include /data/hyperparameters.stan
  
  #include /data/glmer_stuff.stan
  
  #include /data/glmer_stuff2.stan
}
transformed data {
  real poisson_max = pow(2.0, 30.0);
  array[special_case ? t : 0, N] int<lower=1> V = make_V(N,
                                                         special_case ? t : 0,
                                                         v);
  
  #include /tdata/tdata_glm.stan
}
parameters {
  array[has_intercept] real<lower=(link == 1 ? negative_infinity() : 0.0)> gamma;
  
  #include /parameters/parameters_glm.stan
  
  array[family > 6] real<lower=0> aux_unscaled;
  array[family == 8] vector<lower=0>[N] noise;
}
transformed parameters {
  real aux = negative_infinity();
  
  #include /tparameters/tparameters_glm.stan
  
  if (family > 6 && (prior_dist_for_aux == 0 || prior_scale_for_aux <= 0)) 
    aux = aux_unscaled[1];
  else if (family > 6) {
    aux = prior_scale_for_aux * aux_unscaled[1];
    if (prior_dist_for_aux <= 2) 
      aux += prior_mean_for_aux;
  }
  
  if (t > 0) {
    if (special_case == 1) {
      int start = 1;
      theta_L = scale .* (family == 6 ? tau : tau * aux);
      if (t == 1) 
        b = theta_L[1] * z_b;
      else 
        for (i in 1 : t) {
          int end = start + l[i] - 1;
          b[start : end] = theta_L[i] * z_b[start : end];
          start = end + 1;
        }
    } else {
      if (family == 6) 
        theta_L = make_theta_L(len_theta_L, p, 1.0, tau, scale, zeta, rho,
                               z_T);
      else 
        theta_L = make_theta_L(len_theta_L, p, aux, tau, scale, zeta, rho,
                               z_T);
      b = make_b(z_b, theta_L, p, l);
    }
  }
}
model {
  #include /model/make_eta.stan
  
  if (t > 0) {
    #include /model/eta_add_Zb.stan
  }
  if (has_intercept == 1) {
    if (link == 1) 
      eta += gamma[1];
    else 
      eta += gamma[1] - min(eta);
  } else {
    #include /model/eta_no_intercept.stan
  }
  
  if (family == 8) {
    if (link == 1) 
      eta += log(aux) + log(noise[1]);
    else if (link == 2) {
      eta *= aux;
      eta .*= noise[1];
    } else 
      eta += sqrt(aux) + sqrt(noise[1]);
  }
  
  if (has_weights == 0 && prior_PD == 0) {
    if (family != 7) {
      if (link == 1) 
        target += poisson_log_lpmf(y | eta);
      else 
        target += poisson_lpmf(y | linkinv_count(eta, link));
    } else {
      if (link == 1) 
        target += neg_binomial_2_log_lpmf(y | eta, aux);
      else 
        target += neg_binomial_2_lpmf(y | linkinv_count(eta, link), aux);
    }
  } else if (family != 7 && prior_PD == 0) 
    target += dot_product(weights, pw_pois(y, eta, link));
  else if (prior_PD == 0) 
    target += dot_product(weights, pw_nb(y, eta, aux, link));
  
  if (family > 6 && prior_dist_for_aux > 0 && prior_scale_for_aux > 0) {
    real log_half = -0.693147180559945286;
    if (prior_dist_for_aux == 1) 
      target += normal_lpdf(aux_unscaled | 0, 1) - log_half;
    else if (prior_dist_for_aux == 2) 
      target += student_t_lpdf(aux_unscaled | prior_df_for_aux, 0, 1)
                - log_half;
    else 
      target += exponential_lpdf(aux_unscaled | 1);
  }
  
  #include /model/priors_glm.stan
  
  if (family == 8) 
    target += gamma_lpdf(noise[1] | aux, 1);
  
  if (t > 0) {
    real dummy = decov_lp(z_b, z_T, rho, zeta, tau, regularization, delta,
                          shape, t, p);
  }
}
generated quantities {
  real mean_PPD = compute_mean_PPD ? 0 : negative_infinity();
  array[has_intercept] real alpha;
  
  if (has_intercept == 1) {
    if (dense_X) 
      alpha[1] = gamma[1] - dot_product(xbar, beta);
    else 
      alpha[1] = gamma[1];
  }
  
  if (compute_mean_PPD) {
    vector[N] nu;
    #include /model/make_eta.stan
    
    if (t > 0) {
      #include /model/eta_add_Zb.stan
    }
    if (has_intercept == 1) {
      if (link == 1) 
        eta += gamma[1];
      else {
        real shift = min(eta);
        eta += gamma[1] - shift;
        alpha[1] -= shift;
      }
    } else {
      #include /model/eta_no_intercept.stan
    }
    
    if (family == 8) {
      if (link == 1) 
        eta += log(aux) + log(noise[1]);
      else if (link == 2) {
        eta *= aux;
        eta .*= noise[1];
      } else 
        eta += sqrt(aux) + sqrt(noise[1]);
    }
    nu = linkinv_count(eta, link);
    if (family != 7) 
      for (n in 1 : N) {
        if (nu[n] < poisson_max) 
          mean_PPD += poisson_rng(nu[n]);
        else 
          mean_PPD += normal_rng(nu[n], sqrt(nu[n]));
      }
    else 
      for (n in 1 : N) {
        real gamma_temp;
        if (is_inf(aux)) 
          gamma_temp = nu[n];
        else 
          gamma_temp = gamma_rng(aux, aux / nu[n]);
        if (gamma_temp < poisson_max) 
          mean_PPD += poisson_rng(gamma_temp);
        else 
          mean_PPD += normal_rng(gamma_temp, sqrt(gamma_temp));
      }
    mean_PPD /= N;
  }
}

  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined jm.stan
#include /pre/Columbia_copyright.stan
#include /pre/Brilleman_copyright.stan
#include /pre/license.stan

functions {
  #include /functions/common_functions.stan
  #include /functions/bernoulli_likelihoods.stan
  
  #include /functions/binomial_likelihoods.stan
  
  #include /functions/continuous_likelihoods.stan
  
  #include /functions/count_likelihoods.stan
  
  #include /functions/mvmer_functions.stan
  
  #include /functions/jm_functions.stan
}
data {
  #include /data/dimensions_mvmer.stan
  
  #include /data/data_mvmer.stan
  
  #include /data/data_event.stan
  
  #include /data/data_assoc.stan
  
  #include /data/hyperparameters_mvmer.stan
  #include /data/hyperparameters_event.stan
  
  #include /data/hyperparameters_assoc.stan
}
transformed data {
  int<lower=0> e_hs = get_nvars_for_hs(e_prior_dist);
  int<lower=0> a_hs = get_nvars_for_hs(a_prior_dist);
  
  #include /tdata/tdata_mvmer.stan
}
parameters {
  #include /parameters/parameters_mvmer.stan
  
  #include /parameters/parameters_event.stan
  
  #include /parameters/parameters_assoc.stan
}
transformed parameters {
  vector[e_K] e_beta;
  vector[a_K] a_beta;
  vector[basehaz_df] e_aux;
  
  #include /tparameters/tparameters_mvmer.stan
  
  e_beta = make_beta(e_z_beta, e_prior_dist, e_prior_mean, e_prior_scale,
                     e_prior_df, e_global_prior_scale, e_global, e_local,
                     e_ool, e_mix, rep_array(1.0, 0), 0, e_slab_scale,
                     e_caux);
  a_beta = make_beta(a_z_beta, a_prior_dist, a_prior_mean, a_prior_scale,
                     a_prior_df, a_global_prior_scale, a_global, a_local,
                     a_ool, a_mix, rep_array(1.0, 0), 0, a_slab_scale,
                     a_caux);
  e_aux = make_basehaz_coef(e_aux_unscaled, e_prior_dist_for_aux,
                            e_prior_mean_for_aux, e_prior_scale_for_aux);
}
model {
  #include /model/mvmer_lp.stan
  
  {
    vector[nrow_e_Xq] e_eta_q;
    
    if (e_K > 0) 
      e_eta_q = e_Xq * e_beta;
    else 
      e_eta_q = rep_vector(0.0, nrow_e_Xq);
    if (assoc == 1) {
      #include /model/assoc_evaluate.stan
    }
    
    {
      #include /model/event_lp.stan
    }
  }
  
  #include /model/priors_mvmer.stan
  
  beta_lp(e_z_beta, e_prior_dist, e_prior_scale, e_prior_df,
          e_global_prior_df, e_local, e_global, e_mix, e_ool, e_slab_df,
          e_caux);
  beta_lp(a_z_beta, a_prior_dist, a_prior_scale, a_prior_df,
          a_global_prior_df, a_local, a_global, a_mix, a_ool, a_slab_df,
          a_caux);
  basehaz_lp(e_aux_unscaled, e_prior_dist_for_aux, e_prior_scale_for_aux,
             e_prior_df_for_aux);
  if (e_has_intercept == 1) 
    gamma_lp(e_gamma[1], e_prior_dist_for_intercept,
             e_prior_mean_for_intercept, e_prior_scale_for_intercept,
             e_prior_df_for_intercept);
}
generated quantities {
  real e_alpha;
  
  #include /gqs/gen_quantities_mvmer.stan
  
  if (e_has_intercept == 1) 
    e_alpha = e_gamma[1] + norm_const - dot_product(e_xbar, e_beta)
              - dot_product(a_xbar, a_beta);
  else 
    e_alpha = norm_const - dot_product(e_xbar, e_beta)
              - dot_product(a_xbar, a_beta);
}

Warning in './/functions/bernoulli_likelihoods.stan', line 84, column 7, included from
'jm.stan', line 8, column 0: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined lm.stan
#include /pre/Columbia_copyright.stan
#include /pre/license.stan

functions {
  real ll_mvn_ols_qr_lp(vector theta, vector b, real intercept, real ybar,
                        real SSR, real sigma, int N) {
    target += -0.5
              * (dot_self(theta - b) + N * square(intercept - ybar) + SSR)
              / square(sigma) - N * (log(sigma) + 0.91893853320467267);
    return target();
  }
}
data {
  int<lower=0, upper=1> has_intercept;
  int<lower=0, upper=1> prior_dist_for_intercept;
  real<lower=0> prior_scale_for_intercept;
  real prior_mean_for_intercept;
  int<lower=0, upper=1> prior_dist;
  int<lower=0, upper=1> prior_PD;
  real<lower=0> eta;
  
  int<lower=1> J;
  
  array[J] int<lower=1> N;
  int<lower=1, upper=min(N)> K;
  array[J] vector[K] xbarR_inv;
  array[J] real ybar;
  real center_y;
  array[J] real<lower=0> s_Y;
  array[J] vector[K] Rb;
  array[J] real<lower=0> SSR;
  array[J] matrix[K, K] R_inv;
}
transformed data {
  real half_K = 0.5 * K;
  array[J] real sqrt_inv_N;
  array[J] real sqrt_Nm1;
  for (j in 1 : J) {
    sqrt_inv_N[j] = sqrt(1.0 / N[j]);
    sqrt_Nm1[j] = sqrt(N[j] - 1.0);
  }
}
parameters {
  array[K > 1 ? J : 0] unit_vector[K] u;
  array[J * has_intercept] real z_alpha;
  array[J] real<lower=(K > 1 ? 0 : -1), upper=1> R2;
  vector[J * (1 - prior_PD)] log_omega;
}
transformed parameters {
  array[J * has_intercept] real alpha;
  array[J] vector[K] theta;
  array[J] real<lower=0> sigma;
  for (j in 1 : J) {
    real Delta_y = prior_PD == 0 ? s_Y[j] * exp(log_omega[j]) : 1;
    
    if (K > 1) 
      theta[j] = u[j] * sqrt(R2[j]) * sqrt_Nm1[j] * Delta_y;
    else 
      theta[j][1] = R2[j] * sqrt_Nm1[j] * Delta_y;
    
    sigma[j] = Delta_y * sqrt(1 - R2[j]);
    
    if (has_intercept == 1) {
      if (prior_dist_for_intercept == 0) 
        alpha[j] = z_alpha[j];
      else if (prior_scale_for_intercept == 0) 
        alpha[j] = z_alpha[j] * Delta_y * sqrt_inv_N[j]
                   + prior_mean_for_intercept;
      else 
      
        alpha[j] = z_alpha[j] * prior_scale_for_intercept
                   + prior_mean_for_intercept;
    }
  }
}
model {
  for (j in 1 : J) {
    if (prior_PD == 0) {
      real dummy;
      real shift;
      shift = dot_product(xbarR_inv[j], theta[j]);
      dummy = ll_mvn_ols_qr_lp(theta[j], Rb[j],
                               has_intercept == 1 ? alpha[j] + shift : shift,
                               ybar[j], SSR[j], sigma[j], N[j]);
    }
  }
  if (has_intercept == 1 && prior_dist_for_intercept > 0) 
    target += normal_lpdf(z_alpha | 0, 1);
  if (prior_dist == 1) {
    if (K > 1) 
      target += beta_lpdf(R2 | half_K, eta);
    else 
      target += beta_lpdf(square(R2) | half_K, eta) + sum(log(abs(R2)));
  }
}
generated quantities {
  array[J] real mean_PPD;
  array[J] vector[K] beta;
  for (j in 1 : J) {
    real shift;
    shift = dot_product(xbarR_inv[j], theta[j]);
    mean_PPD[j] = normal_rng(has_intercept == 1 ? alpha[j] + shift : shift,
                             sigma[j] * sqrt_inv_N[j]);
    beta[j] = R_inv[j] * theta[j];
  }
}

  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined mvmer.stan
#include /pre/Columbia_copyright.stan
#include /pre/Brilleman_copyright.stan
#include /pre/license.stan

functions {
  #include /functions/common_functions.stan
  #include /functions/bernoulli_likelihoods.stan
  
  #include /functions/binomial_likelihoods.stan
  
  #include /functions/continuous_likelihoods.stan
  
  #include /functions/count_likelihoods.stan
  
  #include /functions/mvmer_functions.stan
}
data {
  #include /data/dimensions_mvmer.stan
  
  #include /data/data_mvmer.stan
  
  #include /data/hyperparameters_mvmer.stan
}
transformed data {
  #include /tdata/tdata_mvmer.stan
}
parameters {
  #include /parameters/parameters_mvmer.stan
}
transformed parameters {
  #include /tparameters/tparameters_mvmer.stan
}
model {
  #include /model/mvmer_lp.stan
  
  #include /model/priors_mvmer.stan
}
generated quantities {
  #include /gqs/gen_quantities_mvmer.stan
}

Warning in './/functions/bernoulli_likelihoods.stan', line 84, column 7, included from
'mvmer.stan', line 8, column 0: Functions
    do not need to be declared before definition; all user defined function
    names are always in scope regardless of defintion order.
  $ ../../../../../install/default/bin/stanc --include-paths="." --auto-format --canonicalize=strip-comments --allow-undefined polr.stan
#include /pre/Columbia_copyright.stan
#include /pre/license.stan

functions {
  real CDF_polr(real x, int link) {
    if (link == 1) 
      return (inv_logit(x));
    else if (link == 2) 
      return (Phi(x));
    else if (link == 3) 
      return (gumbel_cdf(x | 0, 1));
    else if (link == 4) 
      return (inv_cloglog(x));
    else if (link == 5) 
      return (cauchy_cdf(x | 0, 1));
    else 
      reject("Invalid link");
    return x;
  }
  
  vector pw_polr(array[] int y, vector eta, vector cutpoints, int link,
                 real alpha) {
    int N = rows(eta);
    int J = rows(cutpoints) + 1;
    vector[N] ll;
    if (link < 1 || link > 5) 
      reject("Invalid link");
    
    if (alpha == 1) 
      for (n in 1 : N) {
        if (y[n] == 1) 
          ll[n] = CDF_polr(cutpoints[1] - eta[n], link);
        else if (y[n] == J) 
          ll[n] = 1 - CDF_polr(cutpoints[J - 1] - eta[n], link);
        else 
          ll[n] = CDF_polr(cutpoints[y[n]] - eta[n], link)
                  - CDF_polr(cutpoints[y[n] - 1] - eta[n], link);
      }
    else 
      for (n in 1 : N) {
        if (y[n] == 1) 
          ll[n] = CDF_polr(cutpoints[1] - eta[n], link) ^ alpha;
        else if (y[n] == J) 
          ll[n] = 1 - CDF_polr(cutpoints[J - 1] - eta[n], link) ^ alpha;
        else 
          reject("alpha not allowed with more than 2 outcome categories");
      }
    return log(ll);
  }
  
  vector make_cutpoints(vector probabilities, real scale, int link) {
    int C = rows(probabilities) - 1;
    vector[C] cutpoints;
    real running_sum = 0;
    
    if (link == 1) 
      for (c in 1 : C) {
        running_sum += probabilities[c];
        cutpoints[c] = logit(running_sum);
      }
    else if (link == 2) 
      for (c in 1 : C) {
        running_sum += probabilities[c];
        cutpoints[c] = inv_Phi(running_sum);
      }
    else if (link == 3) 
      for (c in 1 : C) {
        running_sum += probabilities[c];
        cutpoints[c] = -log(-log(running_sum));
      }
    else if (link == 4) 
      for (c in 1 : C) {
        running_sum += probabilities[c];
        cutpoints[c] = log(-log1m(running_sum));
      }
    else if (link == 5) 
      for (c in 1 : C) {
        running_sum += probabilities[c];
        cutpoints[c] = tan(pi() * (running_sum - 0.5));
      }
    else 
      reject("invalid link");
    return scale * cutpoints;
  }
  
  real draw_ystar_rng(real lower_, real upper_, real eta, int link) {
    int iter = 0;
    real ystar = not_a_number();
    if (lower_ >= upper_) 
      reject("lower_ must be less than upper_");
    
    if (link == 1) 
      while (!(ystar > lower_ && ystar < upper_)) ystar = logistic_rng(eta,
                                                                    1);
    else if (link == 2) 
      while (!(ystar > lower_ && ystar < upper_)) ystar = normal_rng(eta, 1);
    else if (link == 3) 
      while (!(ystar > lower_ && ystar < upper_)) ystar = gumbel_rng(eta, 1);
    else if (link == 4) 
      while (!(ystar > lower_ && ystar < upper_)) ystar = log(-log1m(
                                                              uniform_rng(
                                                              0, 1)));
    else if (link == 5) 
      while (!(ystar > lower_ && ystar < upper_)) ystar = cauchy_rng(eta, 1);
    else 
      reject("invalid link");
    return ystar;
  }
  
  vector csr_matrix_times_vector2(int m, int n, vector w, array[] int v,
                                  array[] int u, vector b);
}
data {
  #include /data/NKX.stan
  
  int<lower=2> J;
  array[N] int<lower=1, upper=J> y;
  
  #include /data/data_glm.stan
  
  #include /data/weights_offset.stan
  
  real<lower=0> regularization;
  vector<lower=0>[J] prior_counts;
  int<lower=0, upper=1> is_skewed;
  real<lower=0> shape;
  real<lower=0> rate;
  int<lower=0, upper=1> do_residuals;
}
transformed data {
  real<lower=0> half_K = 0.5 * K;
  real<lower=0> sqrt_Nm1 = sqrt(N - 1.0);
  int<lower=0, upper=1> is_constant = 1;
  vector[0] beta_smooth;
  for (j in 1 : J) 
    if (prior_counts[j] != 1) 
      is_constant = 0;
}
parameters {
  simplex[J] pi;
  array[K > 1] unit_vector[K] u;
  real<lower=(K > 1 ? 0 : -1), upper=1> R2;
  array[is_skewed] real<lower=0> alpha;
}
transformed parameters {
  vector[K] beta;
  vector[J - 1] cutpoints;
  {
    real Delta_y;
    if (K > 1) {
      Delta_y = inv_sqrt(1 - R2);
      beta = u[1] * sqrt(R2) * Delta_y * sqrt_Nm1;
    } else {
      Delta_y = inv_sqrt(1 - square(R2));
      beta[1] = R2 * Delta_y * sqrt_Nm1;
    }
    cutpoints = make_cutpoints(pi, Delta_y, link);
  }
}
model {
  #include /model/make_eta.stan
  
  if (has_weights == 0 && prior_PD == 0) {
    if (is_skewed == 0) 
      target += pw_polr(y, eta, cutpoints, link, 1.0);
    else 
      target += pw_polr(y, eta, cutpoints, link, alpha[1]);
  } else if (prior_PD == 0) {
    if (is_skewed == 0) 
      target += dot_product(weights, pw_polr(y, eta, cutpoints, link, 1.0));
    else 
      target += dot_product(weights,
                            pw_polr(y, eta, cutpoints, link, alpha[1]));
  }
  
  if (is_constant == 0) 
    target += dirichlet_lpdf(pi | prior_counts);
  
  if (prior_dist == 1) {
    if (K > 1) 
      target += beta_lpdf(R2 | half_K, regularization);
    else 
      target += beta_lpdf(square(R2) | half_K, regularization) + log(abs(R2));
  }
  if (is_skewed == 1) 
    target += gamma_lpdf(alpha | shape, rate);
}
generated quantities {
  vector[J > 2 ? J : 1] mean_PPD = rep_vector(0, J > 2 ? J : 1);
  vector[do_residuals ? N : 0] residuals;
  vector[J - 1] zeta;
  
  if (dense_X) 
    zeta = cutpoints + dot_product(xbar, beta);
  else 
    zeta = cutpoints;
  if (J == 2) 
    zeta *= -1.0;
  {
    #include /model/make_eta.stan
    
    for (n in 1 : N) {
      int y_tilde;
      vector[J] theta;
      real previous;
      real first = CDF_polr(cutpoints[1] - eta[n], link);
      previous = first;
      if (is_skewed) 
        theta[1] = first ^ alpha[1];
      else 
        theta[1] = first;
      for (j in 2 : (J - 1)) {
        real current = CDF_polr(cutpoints[j] - eta[n], link);
        theta[j] = current - previous;
        previous = current;
      }
      if (is_skewed == 0) 
        theta[J] = 1 - previous;
      else 
        theta[J] = 1 - previous ^ alpha[1];
      if (previous <= 0 || previous >= 1) {
        
      } else if (J == 2) {
        mean_PPD[1] += bernoulli_rng(theta[J]);
      } else {
        y_tilde = categorical_rng(theta);
        mean_PPD[y_tilde] += 1;
      }
      
      if (do_residuals) {
        real ystar;
        if (y[n] == 1) 
          ystar = draw_ystar_rng(negative_infinity(), cutpoints[1], eta[n],
                                 link);
        else if (y[n] == J) 
          ystar = draw_ystar_rng(cutpoints[J - 1], positive_infinity(
                                 ), eta[n], link);
        else 
          ystar = draw_ystar_rng(cutpoints[y[n] - 1], cutpoints[y[n]],
                                 eta[n], link);
        residuals[n] = ystar - eta[n];
      }
    }
    mean_PPD /= (N + 0.0);
  }
}

